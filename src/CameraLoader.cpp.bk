# include "CameraLoader.hpp"


CameraLoader::CameraLoader(std::string inputFile)
{
    filestream.open(inputFile,std::ios::in);
    std::string line;

    safeGetline(filestream, line); //Line 1
    safeGetline(filestream, line); //Line 2

    // Polynomial coefficients for the DIRECT mapping function (ocam_model.ss in MATLAB). These are used by cam2world
    safeGetline(filestream, line); //Line 3
    std::vector<std::string> parsed = split(line, ' ');
    for (std::size_t i = 0; i < std::stof(parsed[0]); ++i)
    {
        model.pol[i] = std::stof(parsed[i+1]);
        //std::cout << model.pol[i] << std::endl;
    }

    safeGetline(filestream, line); //Line 4
    safeGetline(filestream, line); //Line 5
    safeGetline(filestream, line); //Line 6

    // Polynomial coefficients for the inverse mapping function (ocam_model.invpol in MATLAB). These are used by world2cam
    safeGetline(filestream, line); //Line 7
    parsed = split(line, ' ');
    for (int i = 0; i < std::stof(parsed[0]); ++i)
    {
        model.invPol.emplace_back(std::stof(parsed[i+1]));
    }

    safeGetline(filestream, line); //Line 8
    safeGetline(filestream, line); //Line 9
    safeGetline(filestream, line); //Line 10

    // Center: "row" and "column", starting from 0 (C convention)
    safeGetline(filestream, line); //Line 11
    parsed = split(line, ' ');
    model.xc = std::stof(parsed[0]);
    model.yc = std::stof(parsed[1]);

    safeGetline(filestream, line); //Line 12
    safeGetline(filestream, line); //Line 13
    safeGetline(filestream, line); //Line 14

    // Affine parameters "c", "d", "e"
    safeGetline(filestream, line); //Line 15
    parsed = split(line, ' ');
    model.c = std::stof(parsed[0]);
    model.d = std::stof(parsed[1]);
    model.e = std::stof(parsed[2]);

    safeGetline(filestream, line); //Line 16
    safeGetline(filestream, line); //Line 17
    safeGetline(filestream, line); //Line 18

    // Image size: "height" and "width"
    safeGetline(filestream, line); //Line 19
    parsed = split(line, ' ');
    model.height = std::stof(parsed[0]);
    model.width = std::stof(parsed[1]);

    filestream.close();
}

void CameraLoader::word2cam(Eigen::Matrix<float, Eigen::Dynamic, 3> xyzMat, Eigen::Matrix<unsigned char, Eigen::Dynamic, 3> rgbMat)//:
//xyzMat(xyzMat), rgbMat(rgbMat)
{
    uint nPoints = xyzMat.rows();
    Eigen::Array<float,Eigen::Dynamic,1> theta(nPoints,1);
    Eigen::Array<float,Eigen::Dynamic,1> norm(nPoints,1);
    Eigen::Array<float,Eigen::Dynamic,1> rho(nPoints,1);
    Eigen::Array<float,Eigen::Dynamic,1> x(nPoints,1);
    Eigen::Array<float,Eigen::Dynamic,1> y(nPoints,1);
    //Eigen::Array<float,Eigen::Dynamic,2> points2d;    // u, v
    Eigen::Array<float,Eigen::Dynamic,2> points2d(nPoints,2);    // u, v


    norm = (xyzMat.col(0)*xyzMat.col(0) + xyzMat.col(1)*xyzMat.col(1));
    norm = norm.sqrt();
    //std::cout << norm.row(0) << std::endl;

    std::vector<Eigen::Index> idxs_0;
    for(Eigen::Index i=0; i<norm.size(); ++i)
    {
        if(norm(i) == 0)
            //idxs_0.push_back(i);
            norm(i) = FLT_EPSILON;
    }

    //for(std::size_t i = 0; i < idxs_0.size(); ++i)
    //{
        //norm[idxs_0[i]] = FLT_EPSILON;
    //}

    theta = Eigen::atan((xyzMat.col(2).array())/norm);

    
    for(Eigen::Index i=0; i<theta.size(); ++i)
    {
        float x = theta(i);
        //rho(i) = model.pol[0]*(x,4) + model.pol[1]*(x,3) + model.pol[2]*(x,2) + model.pol[3]*(x,4) + model.pol[4];  
        rho(i) = model.pol[4]*(x,4) + model.pol[3]*(x,3) + model.pol[2]*(x,2) + model.pol[1]*(x,4) + model.pol[0];  
    }
    
    x = (xyzMat.col(0).array())/norm*rho;
    y = (xyzMat.col(1).array())/norm*rho;

    points2d.col(0) = x*model.c + y*model.d + model.xc;
    points2d.col(1) = x*model.e + y + model.xc;


    //cv::Mat imageMat = cv::Mat::ones(model.height, model.width, CV_8UC3);
    cv::Mat imageMat = cv::Mat::ones(2708, 8096, CV_8UC3);
    uint8_t* pixelPtr = (uint8_t*)imageMat.data;
    int cn = imageMat.channels();
    cv::Scalar_<uint8_t> bgrPixel;
    size_t tempidx = 0;

    //int uc = 2048;
    //int vc = 854;
    //for(size_t i = 0; i < imageMat.cols; i++)
    //{
        //for(size_t j = imageMat.rows-1; j > 0; j--)
        //{
            //imageMat.at<cv::Vec3b>(j,i)[0] = rgbMat(tempidx,2);
            //imageMat.at<cv::Vec3b>(j,i)[1] = rgbMat(tempidx,1);
            //imageMat.at<cv::Vec3b>(j,i)[2] = rgbMat(tempidx,0);
            ////if ((xyzMat(tempidx,0)) < 0.01 && (xyzMat(tempidx,1)) < 0.01 )
            //int hdif = uc-i;
            //int vdif = vc-j;
            //if (       sqrt(pow(abs(hdif),2) + pow(abs(vdif),2)) > 800              ) 
            //{
                //imageMat.at<cv::Vec3b>(j,i)[0] = 0;
                //imageMat.at<cv::Vec3b>(j,i)[1] = 0;
                //imageMat.at<cv::Vec3b>(j,i)[2] = 0;
            //} 
            //tempidx++;
        //}
            ////std::cout << "i:" << i << std::endl; //<<" " << i  << " "<<std::endl;
    //}
    //std::cout << tempidx << std::endl;

    for(Eigen::Index i=0; i<points2d.rows(); ++i)
    {
        int row = (int)points2d(i,0);
        int col = (int)points2d(i,1);

        //std::cout << row << std::endl;
        //std::cout << col << std::endl;
        //std::cout << "xxxxxxxxxxxxxxxxxxxxxxxxx" << std::endl;
        if (row > 0 && col > 0 && row < 5000 && col<5000)
        {
            imageMat.at<cv::Vec3b>(row,col)[0] = rgbMat(i,2);
            imageMat.at<cv::Vec3b>(row,col)[1] = rgbMat(i,1);
            imageMat.at<cv::Vec3b>(row,col)[2] = rgbMat(i,0);
            //pixelPtr[row*imageMat.cols*cn + col*cn + 0] = rgbMat(i,2); // B
            //pixelPtr[row*imageMat.cols*cn + col*cn + 1] = rgbMat(i,1); // B // G
            //pixelPtr[row*imageMat.cols*cn + col*cn + 2] = rgbMat(i,0); // B // R
        }

    }

    cv::imshow("Display window", imageMat);
    int k = cv::waitKey(0); // Wait for a keystroke in the window
    if(k == 'q')
    {
        cv::destroyAllWindows();
    }

/*
M is a 3xN matrix containing the coordinates of the 3D points: M=[X;Y;Z]
npoints = size(M, 2);
theta = zeros(1,npoints); 

NORM = sqrt(M(1,:).^2 + M(2,:).^2); 

ind0 = find( NORM == 0); %these are the scene points which are along the z-axis             
NORM(ind0) = eps; %this will avoid division by ZERO later                                   

theta = atan( M(3,:)./NORM );                                                             

rho = polyval( pol , theta ); %Distance in pixel of the reprojected points from the image center            

x = M(1,:)./NORM.*rho ;                                         <- 
y = M(2,:)./NORM.*rho ;

%Add center coordinates
m(1,:) = x*c + y*d + xc;
m(2,:) = x*e + y   + yc;
*/
}

CameraLoader::~CameraLoader() 
{
}